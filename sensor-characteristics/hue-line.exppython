{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain = Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nleft_drive_smart = Motor(Ports.PORT1, True)\nright_drive_smart = Motor(Ports.PORT5, False)\ndrivetrain = SmartDrive(left_drive_smart, right_drive_smart, brain_inertial, 219.44, 320, 40, MM, 1.6666666666666667)\nbumper_right = Bumper(brain.three_wire_port.b)\nbumper_left = Bumper(brain.three_wire_port.a)\nradar = Distance(Ports.PORT8)\noptical_servo = Servo(brain.three_wire_port.g)\noptical_orientation = PotentiometerV2(brain.three_wire_port.h)\neye = Optical(Ports.PORT3)\n\n\n# Wait for sensor(s) to fully initialize\nwait(100, MSEC)\n\ndef calibrate_drivetrain():\n    # Calibrate the Drivetrain Inertial\n    sleep(200, MSEC)\n    brain.screen.print(\"Calibrating\")\n    brain.screen.next_row()\n    brain.screen.print(\"Inertial\")\n    brain_inertial.calibrate()\n    while brain_inertial.is_calibrating():\n        sleep(25, MSEC)\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      Assignmetn 3: Sensor Characteristics: Part 4: Hue Line\n#\tAuthor:       Creed, Augie, Nathaniel (nboynick)\n#\tCreated:      2024-02-03\n#\tDescription:  Make the robot follow a colored line on the floor.\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n# Begin project code\n\n# Global Variable\n# recent_hue_color = None\ndistance_travelled = 0                              # in MM\neye_light_enabled = False                           # Check to make sure the light is on before checking for a color\ninternal_checkpoints = [False, False, False, False] # sharp left corner, sharp right corner, void, end\nrecent_colors = []                                  # 5-long list of the most recent colors recorded\ndrivetrain_calibrated = False                       # calibrate_drivetrain fn was run\n\ndef brain_print(display_row, message):\n    # 1: Function names\n    # 2: Distance Travelled\n    # 3: Color Recorded\n    # 4: brain inertial heading\n    # 5: Misc\n    brain.screen.clear_row(display_row)\n    brain.screen.set_cursor(display_row,1)\n    brain.screen.print(message)\n\ndef make_step(step_size=15, direction=FORWARD):\n    if not drivetrain_calibrated:\n        calibrate_drivetrain()\n        drivetrain_calibrated = True\n    global distance_travelled\n    distance_travelled += step_size\n    drivetrain.drive_for(direction, step_size, MM)\n    brain_print(2, str(distance_travelled))\n\n# Color Constants\nCOLORS_ROUGE = 0     # red\nCOLORS_POURPRE = 1   # purple\nCOLORS_BLEU = 2      # blue\nCOLORS_SARCELLE = 3  # teal/turqoise\nCOLORS_VERT = 4      # green\nCOLORS_NOIR = 5      # black\nCOLORS_OTHER = 6     # unknown, outside of defined color borders\n\ndef add_recent_color(color_value):\n    # Make the global variable writable\n    global recent_colors\n    # Add the most recent color\n    recent_colors.append(color_value)\n    # Limit the list to five items\n    if len(recent_colors) > 5:\n        recent_colors.pop(0)\n\ndef hue_to_color(hue_value):\n    # Remove potential rollover values\n    hue_value = hue_value % 360\n    # Initializ return variable\n    return_color = None\n    # Split hue into the expected color ranges\n    if hue_value >= 340:\n        return_color = COLORS_ROUGE\n    elif hue_value >= 285:\n        return_color = COLORS_POURPRE\n    elif hue_value >= 195:\n        return_color = COLORS_BLEU\n    elif hue_value >= 165:\n        return_color = COLORS_SARCELLE\n    elif hue_value >= 75:\n        return_color = COLORS_VERT\n    elif hue_value <= 25:\n        return_color = COLORS_NOIR\n    else:\n        return_color = COLORS_OTHER\n        # Error message if hue value is outside of the expected ranges\n        print(\"Color convert error: Hue: %s Distance: %s -> Somewhere in the orange/yellow range?\")\n    return return_color\n\ndef get_color():\n    # Check that the light is enabled\n    if not eye_light_enabled:\n        eye.set_light(LedStateType.ON)\n        eye_light_enabled = True\n    # Get the sensor readout and assign it to one of our color ranges\n    current_color = float(eye.hue())\n    current_color = hue_to_color(current_color)\n    # Add the color to the recent colors\n    add_recent_color(current_color)\n    # Print color to screen\n    brain_print(3, str(current_color))\n    # Return the current color\n    return current_color\n\ndef offtrack(direction):\n    # Check the most recent color values to find consistencies\n    print(\"Offtrack: \" + str(recent_colors) + \" : \" + str(direction))\n    # Rotate the bot in the provided direction\n    drivetrain.turn_for(direction, 5, DEGREES)\n\ndef corner():\n    global interal_checkpoints\n    # Check which direction this corner should be rotating towards\n    if not internal_checkpoints[0]:\n        direction = LEFT\n        break_colors = [COLORS_BLEU, COLORS_POURPRE, COLORS_ROUGE]\n        internal_checkpoints[0] = True\n    elif not internal_checkpoints[1]:\n        direction = RIGHT\n        break_colors = [COLORS_BLEU, COLORS_SARCELLE, COLORS_VERT]\n        internal_checkpoints[1] = True\n    else:\n        print(\"Corner Error: Corner code called after both corners fullfilled. Distance %s.\" % str(distance_travelled))\n        return\n    # Backtrack to make sure we are back on the color strip\n    make_step(10, REVERSE)\n    # Rotate until we find a color sufficient to stop rotating for\n    drivetrain.turn(direction)\n    while True:\n        current_color = get_color()\n        if current_color in break_colors:\n            break\n    drivetrain.stop()\n\ndef bridge_void():\n    # Update offtrack segment we have completed\n    global internal_checkpoints\n    internal_checkpoints[2] = True\n    # Overrotate to account for drift (should only be 45Â°)\n    drivetrain.turn_for(LEFT, 65, DEGREES)\n    # Continue driving \"straight\" while checking for track\n    break_colors = [COLORS_VERT, COLORS_SARCELLE, COLORS_BLEU, COLORS_POURPRE, COLORS_ROUGE]\n    distance_before = distance_travelled\n    distance_cutoff_triggered = False\n    while True:\n        make_step()\n        current_color = get_color()\n        if current_color in break_colors:\n            break\n        # If robot travelled too far, recover by rotating 90 degrees and searching in the opposite zig-zag pattern\n        if (distance_travelled - distance_before) > 1200:\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n            distance_cutoff_trigerred = True\n    # Adjust to be fully back on track once it is found\n    if current_color in [COLORS_VERT, COLORS_SARCELLE]:\n        make_step(135)\n    elif current_color in [COLORS_BLEU]:\n        make_step(140)\n    elif current_color in [COLORS_POURPRE, COLORS_ROUGE]:\n        make_step(145)\n    else:\n        print(\"bridge_void error: Current color should not have broken out of loop. Color: %s.\" % str(current_color))\n    if distance_cutoff_trigerred:\n        drivetrain.turn_for(RIGHT, 45, DEGREES)\n    else:\n        drivetrain.turn_for(LEFT, 45, DEGREES)\n\ndef bridge_void_2():\n    # Update offtrack segment we have completed\n    global internal_checkpoints\n    internal_checkpoints[2] = True\n    # Attempt to line up straight with the new track\n    make_step(500)\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n    # Perform a zig-zag search pattern\n    drivetrain.turn_for(LEFT, 45, DEGREES)\n    start_distance = distance_travelled\n    recent_turn_direction = 0\n    while True:\n        make_step()\n        current_color = get_color()\n        if current_color in [COLORS_ROUGE, COLORS_POURPRE, COLORS_BLEU, COLORS_SARCELLE, COLORS_VERT]\n            break\n        if (distance_travelled - start_distance) > 150:\n            if recent_turn_direction == 0:\n                recent_turn_direction = 1\n                drivetrain.turn_for(RIGHT, 90, DEGREES)\n            else:\n                recent_turn_direction = 0\n                drivetrain.turn_for(LEFT, 90, DEGREES)\n\ndef victory():\n    # Do Something\n    print(\"Robot sucessfully passed the course.\")\n    pass\n\ndef algorithm_one():\n    global internal_checkpoints\n    brain_print(5, \"alg1\")\n    make_step(30)\n    while True:\n        brain_print(4, str(brain_inertial.heading(DEGREES)))\n        current_color = get_color()\n        if current_color in [COLORS_SARCELLE, COLORS_VERT]:\n            brain_print(1, \"offtrack-left\")\n            offtrack(LEFT)\n        elif current_color in [COLORS_POURPRE, COLORS_ROUGE]:\n            brain_print(1, \"offtrack-right\")\n            offtrack(RIGHT)\n        elif current_color in [COLORS_NOIR]:\n            if not internal_checkpoints[0] or not internal_checkpoints[1]:\n                brain_print(1, \"corner\")\n                corner()\n            elif not internal_checkpoints[2]:\n                brain_print(1, \"bridge-void\")\n                bridge_void()\n            elif not internal_checkpoints[3]:\n                brain_print(1, \"victory\")\n                victory()\n        elif current_color in [COLORS_OTHER]:\n            print(\"ColorError: \" + str(COLORS_OTHER) + \" @ \" + str(distance_travelled))\n        # Avoid corner fn if we are past that point\n        if distance_travelled > 6500:\n            internal_checkpoints[0] = True\n        if distance_travelled > 9000:\n            internal_checkpoints[1] = True\n        make_step()\n\nalgorithm_one()\n","textLanguage":"python","rconfig":[{"port":[1,5,null],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"wheel275in","gearRatio":"60:36","direction":"rev","gyroType":"integrated","width":"295","unit":"mm","wheelbase":"40","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null},{"port":[2],"name":"bumper_right","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[1],"name":"bumper_left","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[8],"name":"radar","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[7],"name":"optical_servo","customName":true,"deviceType":"Servo","deviceClass":"servo","setting":{},"triportSourcePort":22},{"port":[8],"name":"optical_orientation","customName":true,"deviceType":"PotentiometerV2","deviceClass":"potV2","setting":{},"triportSourcePort":22},{"port":[3],"name":"eye","customName":true,"deviceType":"Optical","deviceClass":"optical","setting":{},"triportSourcePort":22}],"slot":6,"platform":"EXP","sdkVersion":"20220726.10.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5SoundsEnabled":false,"target":"Physical"}