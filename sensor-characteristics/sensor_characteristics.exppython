{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain = Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\npotentiometer_h = PotentiometerV2(brain.three_wire_port.h)\nleft_drive_smart = Motor(Ports.PORT1, True)\nright_drive_smart = Motor(Ports.PORT5, False)\ndrivetrain = SmartDrive(left_drive_smart, right_drive_smart, brain_inertial, 219.44, 320, 40, MM, 1.6666666666666667)\nbumper_right = Bumper(brain.three_wire_port.b)\nbumper_left = Bumper(brain.three_wire_port.a)\ndistance_8 = Distance(Ports.PORT8)\noptical_3 = Optical(Ports.PORT3)\noptical_servo = Servo(brain.three_wire_port.g)\n\n\n# Wait for sensor(s) to fully initialize\nwait(100, MSEC)\n\ndef calibrate_drivetrain():\n    # Calibrate the Drivetrain Inertial\n    sleep(200, MSEC)\n    brain.screen.print(\"Calibrating\")\n    brain.screen.next_row()\n    brain.screen.print(\"Inertial\")\n    brain_inertial.calibrate()\n    while brain_inertial.is_calibrating():\n        sleep(25, MSEC)\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n\n#endregion VEXcode Generated Robot Configuration\n# ---------------------------------------------------------------------------- #\n#                                                                              #\n# \tModule:       main.py                                                      #\n# \tAuthor:       Creed, Augie, Nathaniel                                      #\n# \tCreated:      1/27/2024, 4:47:56 PM                                        #\n# \tDescription:  EXP project                                                  #\n#                                                                              #\n# ---------------------------------------------------------------------------- #\n\n### PROJECT SPECIFIC CODE BELOW HERE ###############################################################\n### 1: Active Directionality Sensing\ndef find_light_source(reset_position=True, verbose=False):\n    \"\"\"Finds the direction of the strongest light source.\n\n    The function cycles through all the possible servo motor positions for the optical sensor\n    searching addon on the SquareBot, and returns the rotation degree for the strongest light level\n    that was found.\n\n    @param reset_position:bool Optional argument to rotate the servo (and the attached optical\n                               sensor) back in the direction of the strongest lightsource that was\n                               found. Default: True.\n    @param verbose:bool Optional argument to turn on verbose variable printing for debugging\n                        purposes. This will print the information to the console, and not the VEX\n                        brain's screen. Default: False\n    @return:int The degree rotation of the strongest lightsource found. This considers 0 degrees to\n                be straight in front of the robot, negative degrees to be facing (in the forward\n                driving direction of the robot) towards the left, and positive degrees to be facing\n                towards the right.\n    \"\"\"\n    position_values = {}\n    for i in range(-50, 51, 1):\n        optical_servo.set_position(i, DEGREES)\n        wait(100, MSEC)\n        my_brightness = float(optical_3.brightness())\n        position_values[i] = my_brightness\n    if verbose: print(position_values)\n    max_position = 0\n    my_brightest_so_far = 0\n    for m_key, m_value in position_values.items():\n        if m_value > my_brightest_so_far:\n            max_position = m_key\n            my_brightest_so_far = m_value\n    if verbose: print(max_position)\n    if reset_position:\n        optical_servo.set_position(max_position)\n        wait(600, MSEC)\n    return potentiometer_h.angle(DEGREES)\n\n# print(find_light_source()) # Slot 1\n\n### 2: Accuracy Measurement\nimport math\n\ndef calculate_rms(control_angles, test_angles, descriptor):\n    print(descriptor)\n    print(\"Control Angles:\")\n    print(control_angles)\n    print(\"Test Angles:\")\n    print(test_angles)\n    difference = []\n    for i in range(0,6,1):\n        difference.append(control_angles[i] - test_angles[i])\n    print(\"Differences:\")\n    print(difference)\n    squared_differences = []\n    for value in difference:\n        squared_differences.append(value**2)\n    print(\"Squared Differences:\")\n    print(squared_differences)\n    average = sum(squared_differences)/6\n    print(\"Average:\")\n    print(average)\n    root = math.sqrt(average)\n    print(\"Root of the Average:\")\n    print(root)\n    return root\n\ndef check_error():\n    control_angles = [128.8257, 146.7114, 166.853, 128.8257, 146.7114, 166.853]\n    test_angles_none = [133.0151, 139.7021, 147.8394, 135.9155, 137.5269, 147.7588]\n    test_angles_short = [139.1382, 140.5884, 139.6216, 130.5981, 141.394, 140.0244]\n    test_angles_long = [133.2568, 140.6689, 150.3369, 131.4038, 142.8442, 151.9482]\n    calculate_rms(control_angles, test_angles_none, \"No Scope:\")\n    calculate_rms(control_angles, test_angles_short, \"Short Scope:\")\n    calculate_rms(control_angles, test_angles_long, \"Long Scope:\")\n\n# check_error() # Slot 2\n\n\n### 3: Phototaxis\n\"\"\"Notes to ourselves for this assignmnet part:\nAlgorithm:\n- Do full perimiter sweep for lights. (I.e., perform find_light_source, rotate 90Â°, repeat 4x)\n- Cases: light vs no-light\n  - NO-LIGHT: Random movements of random duration or search pattern (circles, by sqaures, etc.)\n  - LIGHT: * Orient the bot in the direction of the light (i.e., facing straight towards it).\n           * Move closeer to the light (by how much, how fast, based on some criterion such as a\n             registered dip in the light levels being picked up by the optical sensor?)\n           * Once stoping, do we only check in the direction we were travelling or do a full new\n             preimiter scan?\n\nNeeded info: * How long does a full perimiter scan take?\n             * If we attempt to just correct the direction we are already travelling in, how long\n                 would a localized scan take, and thus how much would the bot move during the scan\n                 itself?\n             * How accurate is the heading reported by the drivetrain?\n             * At what point do we consider the output from the optical sensor as a found light\n               source vs just background-light-noise?\n\nPotentially useful commands:\n  * drivetrain.heading() -> Get the current orientation of the drivetrain, and thus the bot\n  * drivetrain.rotation() -> Unsure how this differs from heading()\n  * drivetrain.turn_for() -> Turn the bot right/left by a specified angle\n  * drivetrain.turn_to_heading() -> Turn the bot to a specified, absolute heading\n  * drivetrain.drive_for() -> Move the robot forwards/backwards by a certain distance\n  * drivetrain.set_drive_velocity() -> Set the speed in percentage points\n\"\"\"\n\ncalibrate_drivetrain()\ndrivetrain.turn_for(LEFT, 90, DEGREES) # Slot 3\n\n### 4: Color Track\n","textLanguage":"python","rconfig":[{"port":[8],"name":"potentiometer_h","customName":true,"deviceType":"PotentiometerV2","deviceClass":"potV2","setting":{},"triportSourcePort":22},{"port":[1,5,null],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"wheel275in","gearRatio":"60:36","direction":"rev","gyroType":"integrated","width":"295","unit":"mm","wheelbase":"40","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"}},{"port":[2],"name":"bumper_right","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[1],"name":"bumper_left","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[8],"name":"distance_8","customName":false,"deviceType":"Distance","deviceClass":"distance","setting":{}},{"port":[3],"name":"optical_3","customName":false,"deviceType":"Optical","deviceClass":"optical","setting":{}},{"port":[7],"name":"optical_servo","customName":true,"deviceType":"Servo","deviceClass":"servo","setting":{},"triportSourcePort":22}],"slot":2,"platform":"EXP","sdkVersion":"20220726.10.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5SoundsEnabled":false,"target":"Physical"}