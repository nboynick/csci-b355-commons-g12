{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain = Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\npotentiometer_h = PotentiometerV2(brain.three_wire_port.h)\nleft_drive_smart = Motor(Ports.PORT1, True)\nright_drive_smart = Motor(Ports.PORT5, False)\ndrivetrain = SmartDrive(left_drive_smart, right_drive_smart, brain_inertial, 219.44, 320, 40, MM, 1.6666666666666667)\nbumper_right = Bumper(brain.three_wire_port.b)\nbumper_left = Bumper(brain.three_wire_port.a)\ndistance_8 = Distance(Ports.PORT8)\noptical_3 = Optical(Ports.PORT3)\noptical_servo = Servo(brain.three_wire_port.g)\n\n\n# Wait for sensor(s) to fully initialize\nwait(100, MSEC)\n\ndef calibrate_drivetrain():\n    # Calibrate the Drivetrain Inertial\n    sleep(200, MSEC)\n    brain.screen.print(\"Calibrating\")\n    brain.screen.next_row()\n    brain.screen.print(\"Inertial\")\n    brain_inertial.calibrate()\n    while brain_inertial.is_calibrating():\n        sleep(25, MSEC)\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n\n#endregion VEXcode Generated Robot Configuration\n# ---------------------------------------------------------------------------- #\n#                                                                              #\n# \tModule:       main.py                                                      #\n# \tAuthor:       Creed, Augie, Nathaniel                                      #\n# \tCreated:      1/27/2024, 4:47:56 PM                                        #\n# \tDescription:  EXP project                                                  #\n#                                                                              #\n# ---------------------------------------------------------------------------- #\n\n### 1: Active Directionality Sensing\ndef find_light_source(return_brightness=False, delta_angle=1):\n    \"\"\"Finds the direction of the strongest light source.\n\n    The function cycles through all the possible servo motor positions for the optical sensor\n    searching addon on the SquareBot, and returns the rotation degree for the strongest light level\n    that was found.\n\n    @param return_brightness: bool If true, this will lead to the function returning not only the\n                                   position value, but also the maximum brightness that was found.\n    @return:int The potentiometer value for the direction of the strongest lightsource found. If\n                the return_brightness parameter is provided, then the function returns a tuple of\n                the (potentiometer_value, brightness_value).\n    \"\"\"\n    position_values = []\n    optical_servo.set_position(-50, DEGREES) # It would be better if this and the next line were unnecessary\n    wait(600, MSEC)\n    for i in range(-50, 51, delta_angle):\n        optical_servo.set_position(i, DEGREES)\n        wait(((delta_angle/100)*620+30), MSEC)\n        position_values.append((i, float(optical_3.brightness())))\n    brightest_position = 0\n    highest_brightness = 0\n    for item in position_values:\n        m_key, m_value = item\n        if m_value > highest_brightness:\n            brightest_position = m_key\n            highest_brightness = m_value\n    optical_servo.set_position(brightest_position)\n    wait(620, MSEC)\n    potentiometer_angle = potentiometer_h.angle(DEGREES)\n    print(position_values)\n    print(highest_brightness)\n    print(potentiometer_angle)\n    print(\"----------------------------------\")\n    if return_brightness:\n        return (potentiometer_angle, highest_brightness)\n    return potentiometer_angle\n\n# print(find_light_source(True, 20)) # Slot 1\n\n### 2: Accuracy Measurement\nimport math\n\ndef calculate_rms(control_angles, test_angles, descriptor):\n    print(descriptor)\n    print(\"Control Angles:\")\n    print(control_angles)\n    print(\"Test Angles:\")\n    print(test_angles)\n    difference = []\n    for i in range(0,6,1):\n        difference.append(control_angles[i] - test_angles[i])\n    print(\"Differences:\")\n    print(difference)\n    squared_differences = []\n    for value in difference:\n        squared_differences.append(value**2)\n    print(\"Squared Differences:\")\n    print(squared_differences)\n    average = sum(squared_differences)/6\n    print(\"Average:\")\n    print(average)\n    root = math.sqrt(average)\n    print(\"Root of the Average:\")\n    print(root)\n    return root\n\ndef check_error():\n    control_angles = [128.8257, 146.7114, 166.853, 128.8257, 146.7114, 166.853]\n    test_angles_none = [133.0151, 139.7021, 147.8394, 135.9155, 137.5269, 147.7588]\n    test_angles_short = [139.1382, 140.5884, 139.6216, 130.5981, 141.394, 140.0244]\n    test_angles_long = [133.2568, 140.6689, 150.3369, 131.4038, 142.8442, 151.9482]\n    calculate_rms(control_angles, test_angles_none, \"No Scope:\")\n    calculate_rms(control_angles, test_angles_short, \"Short Scope:\")\n    calculate_rms(control_angles, test_angles_long, \"Long Scope:\")\n\n# check_error() # Slot 2\n\n\n### 3: Phototaxis\ndef check_perimiter():\n    # Check the entire surroundings of the robot for light\n    # Return the positioning of the bot to where it was originally\n    # Return the change in heading needed to position towards the strongest light source\n    find_light_results = []\n    for i in range(0,8,1):\n        find_light_results.append(find_light_source(True)) # returns (potentiometer_angle, highest_brightness)\n        drivetrain.turn_for(RIGHT, 45, DEGREES)\n    pot_of_max_brightness = 0\n    max_brightness = 0\n    rotation_count = 0\n    index = 0\n    for item in find_light_results:\n        pot,bright = item\n        if bright > max_brightness:\n            max_brightness = bright\n            pot_of_max_brightness = pot\n            rotation_count = index\n        index += 1\n    delta_heading = (rotation_count * 45) + (pot_of_max_brightness - 150)\n    direction = RIGHT\n    if delta_heading > 360:\n        delta_heading -= 360\n        direction = RIGHT\n    elif delta_heading > 180:\n        delta_heading = 360 - delta_heading\n        direction = LEFT\n    return (delta_heading, direction, max_brightness)\n\ndef rotate_to_light_source():\n    # Get the suggested new heading from check_perimiter()\n    # Rotate the robot by the necessary amounts\n    m_angle, direction, brightness_level = check_perimiter()\n    drivetrain.turn_for(direction, m_angle, DEGREES)\n    return brightness_level\n\ndef avoid_obstacle():\n    # Circumvent an obstacle that is found in the line of sight of the robot by going around the left of it\n    path_is_blocked = True\n    while path_is_blocked:\n        # drivetrain.stop() # Unnecessary?\n        drivetrain.drive_for(REVERSE, 3, INCHES)\n        drivetrain.stop()\n        drivetrain.turn_for(LEFT, 90, DEGREES)\n        drivetrain.drive_for(FORWARD, 10, INCHES) # Check to match this value to the SquareBot length\n        drivetrain.turn_for(RIGHT, 90, DEGREES)\n        drivetrain.drive_for(FORWARD, 3, INCHES)\n        if distance_8.object_distance(INCHES) > 6: path_is_blocked = False\n\nimport random\n\ndef make_random_move():\n    turn_angle = random.randint(0, 360)\n    drive_distance = random.randint(1, 4)\n    drivetrain.turn_for(RIGHT, turn_angle, DEGREES)\n    drivetrain.drive_for(FORWARD, drive_distance, INCHES)\n\ndef search_for_light(minimum_solution_light_level=0.3): # the \"main\" function for part 3\n    calibrate_drivetrain()\n    brightness_found = 0\n    while True:\n        if distance_8.object_distance(INCHES) < 6:\n            avoid_obstacle()\n        # if brightness_found > minimum_solution_light_level and distance_8.object_distance(INCHES) < :\n        #     break # Exit the while loop once we get close enough to the light source\n        if brightness_found < minimum_solution_light_level:\n            make_random_move()\n            brightness_found = rotate_to_light_source()\n        else:\n            drivetrain.drive_for(FORWARD, 4, INCHES)\n            m_position, m_brightness = find_light_source(True)\n            normalized_position = m_position - 150\n            if normalized_position < 0:\n                drivetrain.turn_for(LEFT, (normalized_position * (-1)), DEGREES)\n            else:\n                drivetrain.turn_for(RIGHT, normalized_position, DEGREES)\n            brightness_found = m_brightness\n\n\n# search_for_light() # Slot 3\n\n\n### 4: Color Track","textLanguage":"python","rconfig":[{"port":[8],"name":"potentiometer_h","customName":true,"deviceType":"PotentiometerV2","deviceClass":"potV2","setting":{},"triportSourcePort":22},{"port":[1,5,null],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"wheel275in","gearRatio":"60:36","direction":"rev","gyroType":"integrated","width":"295","unit":"mm","wheelbase":"40","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null},{"port":[2],"name":"bumper_right","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[1],"name":"bumper_left","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[8],"name":"distance_8","customName":false,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[3],"name":"optical_3","customName":false,"deviceType":"Optical","deviceClass":"optical","setting":{},"triportSourcePort":22},{"port":[7],"name":"optical_servo","customName":true,"deviceType":"Servo","deviceClass":"servo","setting":{},"triportSourcePort":22}],"slot":7,"platform":"EXP","sdkVersion":"20220726.10.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5SoundsEnabled":false,"target":"Physical"}