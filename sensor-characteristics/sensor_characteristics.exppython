{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain = Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\npotentiometer_h = PotentiometerV2(brain.three_wire_port.h)\nleft_drive_smart = Motor(Ports.PORT1, True)\nright_drive_smart = Motor(Ports.PORT5, False)\ndrivetrain = SmartDrive(left_drive_smart, right_drive_smart, brain_inertial, 219.44, 320, 40, MM, 1.6666666666666667)\nbumper_right = Bumper(brain.three_wire_port.b)\nbumper_left = Bumper(brain.three_wire_port.a)\ndistance_8 = Distance(Ports.PORT8)\noptical_3 = Optical(Ports.PORT3)\noptical_servo = Servo(brain.three_wire_port.g)\n\n\n# Wait for sensor(s) to fully initialize\nwait(100, MSEC)\n\ndef calibrate_drivetrain():\n    # Calibrate the Drivetrain Inertial\n    sleep(200, MSEC)\n    brain.screen.print(\"Calibrating\")\n    brain.screen.next_row()\n    brain.screen.print(\"Inertial\")\n    brain_inertial.calibrate()\n    while brain_inertial.is_calibrating():\n        sleep(25, MSEC)\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n\n#endregion VEXcode Generated Robot Configuration\n# ---------------------------------------------------------------------------- #\n#                                                                              #\n# \tModule:       main.py                                                      #\n# \tAuthor:       Creed, Augie, Nathaniel                                      #\n# \tCreated:      1/27/2024, 4:47:56 PM                                        #\n# \tDescription:  EXP project                                                  #\n#                                                                              #\n# ---------------------------------------------------------------------------- #\n\n### 1: Active Directionality Sensing\ndef find_light_source(return_brightness=False, delta_angle=1):\n    \"\"\"Finds the direction of the strongest light source.\n\n    The function cycles through all the possible servo motor positions for the optical sensor\n    searching addon on the SquareBot, and returns the rotation degree for the strongest light level\n    that was found.\n\n    @param return_brightness: bool If true, this will lead to the function returning not only the\n                                   position value, but also the maximum brightness that was found.\n    @return:int The potentiometer value for the direction of the strongest lightsource found. If\n                the return_brightness parameter is provided, then the function returns a tuple of\n                the (potentiometer_value, brightness_value).\n    \"\"\"\n    position_values = {}\n    optical_servo.set_position(-50, DEGREES) # It would be better if this and the next line were unnecessary\n    wait(600, MSEC)\n    for i in range(-50, 51, delta_angle):\n        optical_servo.set_position(i, DEGREES)\n        wait(100, MSEC)\n        position_values[i] = float(optical_3.brightness())\n    brightest_position = 0\n    highest_brightness = 0\n    for m_key, m_value in position_values.items():\n        if m_value > highest_brightness:\n            brightest_position = m_key\n            highest_brightness = m_value\n    optical_servo.set_position(brightest_position)\n    wait(600, MSEC)\n    potentiometer_angle = potentiometer_h.angle(DEGREES)\n    if return_brightness:\n        return (potentiometer_angle, highest_brightness)\n    return potentiometer_angle\n\n# print(find_light_source()) # Slot 1\n\n### 2: Accuracy Measurement\nimport math\n\ndef calculate_rms(control_angles, test_angles, descriptor):\n    print(descriptor)\n    print(\"Control Angles:\")\n    print(control_angles)\n    print(\"Test Angles:\")\n    print(test_angles)\n    difference = []\n    for i in range(0,6,1):\n        difference.append(control_angles[i] - test_angles[i])\n    print(\"Differences:\")\n    print(difference)\n    squared_differences = []\n    for value in difference:\n        squared_differences.append(value**2)\n    print(\"Squared Differences:\")\n    print(squared_differences)\n    average = sum(squared_differences)/6\n    print(\"Average:\")\n    print(average)\n    root = math.sqrt(average)\n    print(\"Root of the Average:\")\n    print(root)\n    return root\n\ndef check_error():\n    control_angles = [128.8257, 146.7114, 166.853, 128.8257, 146.7114, 166.853]\n    test_angles_none = [133.0151, 139.7021, 147.8394, 135.9155, 137.5269, 147.7588]\n    test_angles_short = [139.1382, 140.5884, 139.6216, 130.5981, 141.394, 140.0244]\n    test_angles_long = [133.2568, 140.6689, 150.3369, 131.4038, 142.8442, 151.9482]\n    calculate_rms(control_angles, test_angles_none, \"No Scope:\")\n    calculate_rms(control_angles, test_angles_short, \"Short Scope:\")\n    calculate_rms(control_angles, test_angles_long, \"Long Scope:\")\n\n# check_error() # Slot 2\n\n\n### 3: Phototaxis\ndef check_perimiter():\n    # Check the entire surroundings of the robot for light\n    # Return the positioning of the bot to where it was originally\n    # Return the change in heading needed to position towards the strongest light source\n    find_light_results = []\n    for i in range(0,8,1):\n        find_light_results.append(find_light_source(True)) # returns (potentiometer_angle, highest_brightness)\n        drivetrain.turn_for(RIGHT, 45, DEGREES)\n    pot_of_max_brightness = 0\n    max_brightness = 0\n    rotation_count = 0\n    for index,item in enumerate(find_light_results):\n        pot,bright = item\n        if bright > max_brightness:\n            max_brightness = bright\n            pot_of_max_brightness = pot\n            rotation_count = index\n    delta_heading = (rotation_count * 45) + (pot_of_max_brightness - 150)\n    direction = RIGHT\n    if delta_heading > 180:\n        delta_heading = 360 - delta_heading\n        direction = LEFT\n    return (delta_heading, direction)\n\ndef rotate_to_light_source():\n    # Get the suggested new heading from check_perimiter()\n    # Rotate the robot by the necessary amounts\n    m_angle, direction = check_perimiter()\n    drivetrain.turn_for(direction, m_angle, DEGREES)\n    return 0\n\n### 4: Color Track\n\n### Other Stuff\ndef servo_motor_timing_test(timings=[5,10,25,50,70,100,150,200]):\n    optical_servo.set_position(50, DEGREES)\n    wait(1000, MSEC)\n    print(\"The reported angle should be:\")\n    print(potentiometer_h.angle(DEGREES))\n    for i in timings:\n        print(\"Testing %s MSEC:\" % str(i))\n        optical_servo.set_position(-50, DEGREES)\n        wait(1000, MSEC)\n        optical_servo.set_position(50, DEGREES)\n        wait(i, MSEC)\n        print(potentiometer_h.angle(DEGREES))\n        print(\"---------------\")","textLanguage":"python","rconfig":[{"port":[8],"name":"potentiometer_h","customName":true,"deviceType":"PotentiometerV2","deviceClass":"potV2","setting":{},"triportSourcePort":22},{"port":[1,5,null],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"wheel275in","gearRatio":"60:36","direction":"rev","gyroType":"integrated","width":"295","unit":"mm","wheelbase":"40","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null},{"port":[2],"name":"bumper_right","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[1],"name":"bumper_left","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[8],"name":"distance_8","customName":false,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[3],"name":"optical_3","customName":false,"deviceType":"Optical","deviceClass":"optical","setting":{},"triportSourcePort":22},{"port":[7],"name":"optical_servo","customName":true,"deviceType":"Servo","deviceClass":"servo","setting":{},"triportSourcePort":22}],"slot":3,"platform":"EXP","sdkVersion":"20220726.10.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5SoundsEnabled":false,"target":"Physical"}